#version 460
#extension GL_GOOGLE_include_directive: enable
#extension GL_ARB_shader_clock : enable
#extension GL_EXT_shader_non_constant_global_initializers: enable

#include "base_raytrace.glsl"
#include "raytrace_utils.glsl"

layout (set = 0, binding = 0) uniform _CameraData {
    CameraData c;
} camBuffer;

layout (set = 1, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout (rgba32f, set = 1, binding = 1) uniform image2D image;

layout (push_constant) uniform _GlobalData {
    GlobalData g;
} globalConstants;

layout (location = 0) rayPayloadEXT HitInfo payload;

void main()
{
    uint seed = getSeed(gl_LaunchIDEXT.x + gl_LaunchIDEXT.x * gl_LaunchIDEXT.y, uint(clockARB()));
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 currentWeight = vec3(1.0);

    for (uint i = 0; i < globalConstants.g.antiAliasSamples; i++)
    {
        // Get UV coordinates, normalized to value 0-1
        const vec2 pixCenter = vec2(gl_LaunchIDEXT.xy) + vec2(random(seed), random(seed));
        const vec2 uv = (pixCenter / vec2(gl_LaunchSizeEXT.xy));

        // Convert the UV-coordinates to -1 to 1 range to calculate direction
        const vec2 ndc = uv * 2.0 - 1.0;

        const vec3 rayOrigin = camBuffer.c.position;
        const vec4 rayDirection = normalize(vec4(ndc.x, ndc.y, 1.0, 1.0) * camBuffer.c.invViewProj);

        uint rayFlags = gl_RayFlagsOpaqueEXT;
        float tMin = camBuffer.c.nearPlane;
        float tMax = camBuffer.c.farPlane;

        payload.seed = seed;
        payload.depth = 0;
        payload.rayOrigin = rayOrigin;
        payload.rayDirection = rayDirection.xyz;
        payload.weight = vec3(0.0);

        vec3 rayColor = vec3(0.0);
        for (; payload.depth < globalConstants.g.maxBounces; payload.depth++) {
            traceRayEXT(topLevelAS, // Acceleration Structure
            rayFlags, // Ray flags
            0xFF, // Culling Mask. ANDed with mask set in acceleration structure.
            0, // SBT Record offset
            0, // SBT Record stride
            0, // Miss Shader Index
            payload.rayOrigin, // Ray origin
            tMin, // Min Ray hit distance
            payload.rayDirection, // Ray direction
            tMax, // Max Ray hit distance
            0 // Payload location
            );

            rayColor.rgb += payload.color.rgb * currentWeight.rgb;
            currentWeight *= payload.weight;
        }
        finalColor.rgb += rayColor;
    }
    finalColor.rgb = finalColor.rbg / globalConstants.g.antiAliasSamples;

    // Accumulate color
    if (globalConstants.g.frameIndex > 0)
    {
        const float t = 1.0f / (globalConstants.g.frameIndex + 1);
        const vec3 oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        finalColor = vec4(mix(oldColor, finalColor.rgb, t), 1.0f);
    }
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), finalColor);
}
